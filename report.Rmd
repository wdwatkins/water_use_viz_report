---
title: "Water Use 2015 data"
author: "David Watkins"
date: "July 13, 2018"
output: html_document
---
[https://owi.usgs.gov/vizlab/water-use-15](https://owi.usgs.gov/vizlab/water-use-15)
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(googleAnalyticsR)
library(googleAuthR)
library(dplyr)
library(ggplot2)
library(lubridate)
```
## Traffic attribution

Unlike previous visualizations, Twitter was the biggest driver of traffic.  
```{r not_with_dims, echo = FALSE, message = FALSE}
view <- "177200146"
release_date <- as.Date("2018-06-19")
gar_auth_service('~/.vizlab/VIZLAB-a48f4107248c.json')

source('bulk_sessions.R')
sessions_plot <- invisible(get_time_series_plot(view, release_date))
print(sessions_plot)

total_sessions <- invisible(google_analytics(viewId = view, 
                                   date_range = c(start = release_date, end = Sys.Date()),
                                   metrics = "sessions")$sessions)

source_table <- get_campaign_source_table(view, release_date) %>% 
  mutate(frac_internal = round(frac_internal, digits = 2)) %>% arrange(desc(source_campaign_total))
DT::datatable(source_table, colnames = c("Campaign", "Source", "Keyword", "Sessions", "Fraction on network"),
              caption = "Sessions grouped by UTM parameters")


```

Also unlike previous recent visualizations, desktop accounted for the majority of traffic instead of mobile.
```{r platforms}

platforms <- invisible(get_platform_plot(view, release_date))
print(platforms)
```

## Utilizing custom dimensions
Since traffic to this viz was relatively low, this section is more of a demonstration of custom dimensions than a specific analysis of user behavior for this viz.  [This blog post](https://www.simoahava.com/analytics/13-useful-custom-dimensions-for-google-analytics/#2-good-all-around-custom-dimensions) provides a good guide to them. We implemented the first three dimensions (hit timestamp, session ID, and client ID).  This lets us know when a particular event happened, and unique identifier to group it with other events in the same session or by the same client.

Scroll tracking was added to this viz with some extra javascript.  Having a session ID allows us to eliminate duplicate events within the same session (for instance if someone scrolled part way down, then scrolled back up, triggering scroll events towards the top multiple times).
```{r new_dims, fig.align='center', echo = FALSE, message=FALSE}
events <- google_analytics(viewId = view, 
                           date_range = c(start = release_date, end = Sys.Date()),
                           dimensions = c("eventAction", "eventLabel", "dimension2"),
                           metrics = c("totalEvents"), max = -1, 
                           anti_sample = TRUE) %>% rename(sessionID = dimension2)
scrolls <- events %>% filter(eventAction == "scroll") %>% group_by(eventLabel) %>% 
  summarize(n=length(unique(sessionID))) %>% arrange(desc(n)) %>% 
  mutate(fraction_of_sessions = round(n/total_sessions, digits = 2))
knitr::kable(scrolls, col.names = c("Scroll point", "Sessions", "Fraction of sessions"))  
```

Changing map views (different state or national zoom) was recorded with another custom event.  The session ID dimension allows us to associate all views that occured in the same session.  Without this, we could only compute an average, in this case about 5 view changes per session.  This obscures that a majority of sessions never changed the map view.
```{r view_changes, echo = FALSE, message=FALSE}
view_changes <- events %>% filter(eventAction == "update view")
view_change_sessions <- length(unique(view_changes$sessionID))
no_view_changes <- total_sessions - view_change_sessions
summed_view_changes <- view_changes %>% group_by(sessionID) %>% 
  summarize(n_view_changes=n()) %>% 
  ungroup() %>% group_by(n_view_changes) %>% summarize(n_sessions=n()) %>% 
  bind_rows(data.frame(n_view_changes=0, n_sessions=no_view_changes))
avg_view_changes <- round(sum(view_changes$totalEvents)/total_sessions, digits = 1)
ggplot(summed_view_changes, aes(x = n_view_changes, y = n_sessions)) + 
  geom_col() + scale_x_continuous(minor_breaks = 1:30, breaks = seq(0,30,5)) +
  xlab("Number of view changes") + ylab("Sessions") + 
  annotate("text", label = paste("Average", avg_view_changes, "view changes per session"), x = 15, y=1500, size = 5)
```

We can do the same with the events that recorded changing the category on the map.  Similarly, the average does not tell the whole story of this distribution.    
```{r cat_changes}
cat_changes <- events %>% filter(grepl(pattern = "update category", x = eventAction)) 
no_cat_changes <- total_sessions - length(unique(cat_changes$sessionID))
summed_cat_changes <- cat_changes %>% 
  group_by(sessionID) %>% summarize(n_cat_changes = n()) %>% ungroup() %>% 
  group_by(n_cat_changes) %>% summarize(n_sessions=n()) %>% 
  bind_rows(data.frame(n_cat_changes=0, n_sessions = no_cat_changes)) %>% 
  arrange(n_cat_changes)
avg_cat_changes <- round(sum(cat_changes$totalEvents)/total_sessions, digits = 1)
ggplot(summed_cat_changes, aes(x = n_cat_changes, y = n_sessions)) + 
  geom_col() + scale_x_continuous(minor_breaks = 1:30, breaks = seq(0,30,5)) +
  xlab("Number of category changes") + ylab("Sessions") +
  annotate("text", label = paste("Average", avg_cat_changes, "category changes per session"), x = 15, y=1000, size = 5)
```

Now we know that a majority of sessions didn't change the map view, and a smaller but still substantial portion didn't change the category either.  We might suspect that these two groups overlap.  Since there is a unique identifier associated these events, we can test this.

``` {r custom_dims}

```